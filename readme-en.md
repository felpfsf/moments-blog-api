# moments-blog

To create a REST API using Node.js, I chose to use the Fastify framework as the base for the project. To ensure the validation of the input data for HTTP requests, I used the Zod library as a schema validation mechanism.

To manage user authentication, I chose to use JWT (JSON Web Token) as an authentication mechanism. This allowed me to implement a secure and easily scalable authentication solution. To store the data for the application, I used Prisma as an ORM (Object-Relational Mapping) and MongoDB as the database, allowing me to create a flexible and easily manageable database system.

To implement the routes, I created several separate modules, each responsible for managing a specific functionality. This allowed me to divide the code into more manageable and easier to understand parts. To export the schemas generated with Zod I had to use the fastify-type-provider-zod library, it allowed me to manage the appropriate schemas for each route, ensuring better data typing security.

I used Insomnia to perform functional testing for each available endpoint, through it I was able to perform several integration tests.

During development I encountered the problem that errors generated by Zod were being returned with incorrect formatting. This was because the library did not have a standard formatting for the generated errors, which could be confusing for users of the API. To solve this problem, I had to create a mechanism to format the errors generated by Zod in a clearer and easier to understand way. This involved creating a function that received the errors generated by Zod and formatted them according to a specific pattern.

```js
  server.setErrorHandler((error, request, reply) => {
    const toSend = {
      message: 'Validation error',
      errors: JSON.parse(error.message),
      statusCode: error.statusCode || 500
    }

    reply.code(toSend.statusCode).send(toSend)
  })
```

In addition, I chose to separate the validation schemas created with Zod into a separate file, as well as the other user functions. This allowed me to keep the code more organized and easier to understand.

These changes were important to ensure that the API was easy to use and that the generated errors were clear and precise, which was essential to ensure the quality and functionality of the API.

The API I created has the following endpoints:

  **`POST /users`**: endpoint to create a new user in the database. This endpoint receives a JSON object with the user's data (name, email, password, and password confirmation) and creates a new record in the database.

  **`POST /login`**: endpoint to log in a user. This endpoint receives a JSON object with the user's email and password, and returns a valid JWT token if the credentials are correct.

  **`GET /users`**: endpoint to list all users registered in the database. This endpoint does not receive any parameters and returns a list with all registered users. This endpoint is protected by JWT authentication, which means it can only be accessed if the user provides a valid token.

  **`GET /users/dashboard`**: endpoint to get a specific user by their ID. This endpoint receives the user's ID as a parameter and returns the data for that user. This endpoint is protected by JWT authentication, which means it can only be accessed if the user provides a valid token.

  **`PATCH /users/:id`**: endpoint to update the data of a specific user. This endpoint receives the user's ID and a JSON object with the data to be updated, and updates the user's data in the database. This endpoint is also protected by JWT authentication.

  **`DELETE /users/:id`**: endpoint to delete a user from the database. This endpoint receives the user's ID as a parameter and deletes the user's record from the database. This endpoint is also protected by JWT authentication.

  These are the main endpoints of the API I created. They are designed to provide a wide range of functionality for managing users, including creating, listing, updating, and deleting users. In addition, the API also includes a login route to allow users to log in and receive a valid JWT token to access the endpoints protected by authentication.

Overall, the development of this project was a very enriching experience. In addition to allowing me to learn about REST API development with Node.js and about best software development practices, the project also allowed me to apply the knowledge acquired in a real-life situation and create a functional API.

The use of tools such as Fastify, Zod, JWT, and Prisma was also very helpful in ensuring that the API was developed in a fast, secure, and scalable way. This allowed me to focus on the development of the functionality rather than worrying about low-level issues, which was very valuable.

In the end, I was very satisfied with the final result and believe it was a very enriching experience that helped me grow as a developer.
